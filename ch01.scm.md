Building Abstractions with Procedures
=====================================

Exercise 1.2
------------

*Translate the following expression into prefix form*

![$ $\frac {5 + 4 + (2 - (3 - (6 + \frac {4} {5})))} {3(6 - 2)(2 - 7)}$ $](img/ex1.2.png?raw=true)

```scheme
(/ (+ 5 4 (- 2 (- 3 (+ 6 (/ 4 5)))))
   (* 3 (- 6 2) (- 2 7)))
```

Exercise 1.3
------------

*Define a procedure that takes three numbers as arguments and returns the sum
of the squares of the two larger numbers.*

```scheme
(define (ex1.3 x y z)
  (define (square x) (* x x))
  (define (max x y) (if (> x y) x y))
  (define (sum-of-squares x y) (+ (square x) (square y)))
  (if (> x y)
    (+ (sum-of-squares x (max y z)))
    (+ (sum-of-squares y (max x z)))))
```

Exercise 1.4
------------

*Describe the behaviour of the following procedure:*

    (define (a-plus-abs-b a b)
      ((if (> b 0) + -) a b))

This will add b to a if b is positive, otherwise it will subtract it.
In other words it adds the absolute value of b to a.

Exercise 1.5
------------

*Given the procedures:*

    (define (p) (p))
    (define (test x y)
      (if (= x 0)
        0
        y))

*What would be the result of running: (test 0 (p))?*

The answer is of course an infinite loop as it will attempt to evaluate the
value of (p) before calling the function (test) which discards it.  This is in
contrast to what would happen under normal-order (lazy) evaluation, in which
case the computation in the else branch of the if statement would never be run
and so (test 0 (p)) would simply return 0.

Exercise 1.6
------------

*What would happen if we attempted to use the following implementation to
compute square roots?*

    (define (new-if predicate then-clause else-clause)
      (cond (predicate then-clause)
            (else else-clause)))
    (define (sqrt-iter guess x)
      (new-if (good-enough? guess x)
              guess
              (sqrt-iter (improve guess x)
                         x)))

The answer is an infinite loop, for the same reasons as outlined above.

Exercise 1.7
------------

*Design a square-root procedure that stops when the change is a very small
fraction of the guess, rather than when the square of the guess is a small
number away from the required result.*

```scheme
(define (sqrt x)
  (define (good-enough? guess last-guess)
    (< (/ (abs (- guess last-guess))
          guess)
       0.001))

  (define (average x y)
    (/ (+ x y) 2))

  (define (improve guess x)
    (average guess (/ x guess)))

  (define (sqrt-iter guess last-guess x)
    (if (good-enough? guess last-guess)
      guess
      (sqrt-iter (improve guess x)
                 guess
                 x)))

  (sqrt-iter (improve 1.0 x) 1.0 x))
```

Exercise 1.8
------------

*Implement a cube-root procedure analogous to the square-root procedure.*

```scheme
(define (cbrt x)
  (define (good-enough? guess last-guess)
    (< (/ (abs (- guess last-guess))
          guess)
       0.001))

  (define (improve guess x)
    (/ (+ (/ x (square guess)) (* 2 guess))
       3))

  (define (cbrt-iter guess last-guess x)
    (if (good-enough? guess last-guess)
      guess
      (cbrt-iter (improve guess x)
                 guess
                 x)))

  (cbrt-iter (improve 1.0 x) 1.0 x))
```

Exercise 1.9
------------

*Using the substitution model, illustrate the process generated by each of the
following procedures in evaluating `(+ 4 5)`.  Are these processes iterative or
recursive?*

    (define (+ a b)
      (if (= a 0)
          b
          (inc (+ (dec a) b))))

    (define (+ a b)
      (if (= a 0)
          b
          (+ (dec a) (inc b))))

Here is the first one, which is recursive:

```
(+ 4 5)
(inc (+ 3 5))
(inc (inc (+ 2 5)))
(inc (inc (inc (+ 1 5))))
(inc (inc (inc (inc (+ 0 5)))))
(inc (inc (inc (inc 5))))
(inc (inc (inc 6)))
(inc (inc 7)
(inc 8)
9
```

And the second, which is iterative:

```
(+ 4 5)
(+ 3 6)
(+ 2 7)
(+ 1 8)
(+ 0 9)
9
```

Exercise 1.10
-------------

*The following procedure computes a mathematical function calles Ackermann's
function.*

```scheme
(define (A x y)
  (cond ((= y 0) 0)
        ((= x 0) (* 2 y))
        ((= y 1) 2)
        (else    (A (- x 1)
                    (A x (- y 1))))))
```

*What are the values of the following expressions? `(A 1 10)`, `(A 2 4)`,
`(A 3 3)`*

```
(A 1 10)
(A 0 (A 1 9))
(A 0 (A 0 (A 1 8)))
(A 0 (A 0 (A 0 (A 1 7))))
(A 0 (A 0 (A 0 (A 0 (A 1 6)))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 1 5))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 4)))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 3))))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 2)))))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 1))))))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 2)))))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 4))))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 8)))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 16))))))
(A 0 (A 0 (A 0 (A 0 (A 0 32)))))
(A 0 (A 0 (A 0 (A 0 64))))
(A 0 (A 0 (A 0 128)))
(A 0 (A 0 256))
(A 0 512)
1024
```

```
(A 2 4)
(A 1 (A 2 3))
(A 1 (A 1 (A 2 2)))
(A 1 (A 1 (A 1 (A 2 1))))
(A 1 (A 1 (A 1 2)))
(A 1 (A 1 (A 0 (A 1 1))))
(A 1 (A 1 (A 0 2)))
(A 1 (A 1 4))
(A 1 (A 0 (A 1 3)))
(A 1 (A 0 (A 0 (A 1 2))))
(A 1 (A 0 (A 0 (A 0 (A 1 1)))))
(A 1 (A 0 (A 0 (A 0 2))))
(A 1 (A 0 (A 0 4)))
(A 1 (A 0 8))
(A 1 16)
; ...(A 1 n) == 2ⁿ...
65536
```

```
(A 3 3)
(A 2 (A 3 2))
(A 2 (A 2 (A 3 1)))
(A 2 (A 2 2))
(A 2 (A 1 (A 2 1)))
(A 2 (A 1 2))
(A 2 (A 0 (A 1 1)))
(A 2 (A 0 2))
(A 2 4)
(A 1 (A 2 3))
(A 1 (A 1 (A 2 2)))
(A 1 (A 1 (A 1 (A 2 1))))
(A 1 (A 1 (A 1 2)))
(A 1 (A 1 4))
(A 1 16)
65536
```

*Give concise mathematical definitions for the functions computed by the
procedures `f`, `g`, and `h` below, given positive integer values of `n`.  For
example, `(k n)` computes 5n².*

```scheme
(define (f n) (A 0 n))
(define (g n) (A 1 n))
(define (h n) (A 2 n))
(define (k n) (* 5 n n))
```

![$ $f(n) = 2n$ $](img/ex1.10-1.png?raw=true)

![$ $g(n) = 2^n$ $](img/ex1.10-2.png?raw=true)

![$ $h(n) = 2^{2^n}$ $](img/ex1.10-3.png?raw=true)

Exercise 1.11
-------------

*A function `f` is defined by the rule that `f(n) = n` if `n < 3` and `f(n) =
f(n - 1) + 2f(n - 2) + 3f(n - 3)` if n ≥ 3.*

*Write a procedure that computes `f` by means of a recursive process.*

```scheme
(define (f n)
  (if (< n 3)
      n
      (+ (f (- n 1))
         (* 2 (f (- n 2)))
         (* 3 (f (- n 3))))))
```

*Write a procedure that computes `f` by means of an iterative process.*

```scheme
(define (f-iter a b c count)
  (if (= count 0)
    a
    (f-iter b
            c
            (+ c (* 2 b) (* 3 a))
            (- count 1))))

(define (f n)
  (f-iter 0 1 2 n))
```

Exercise 1.12
-------------

*Write a procedure that computes elements of Pascal's triangle by means of a
recursive process.*

```scheme
(define (pascals-triangle row index)
  (if (or (= index 1) (= index row))
      1
      (+ (pascals-triangle (- row 1) (- index 1))
         (pascals-triangle (- row 1) index))))
```

Note that this solution performs no bounds checking, so passing indices ≤ 0 or >
row won't work.

Exercise 1.13
-------------

*Prove that `Fib(n)` is the closest integer to `Φⁿ/√5`, where `Φ = (1 + √5)/2`.*

We are given that `Φ² = Φ + 1`, and we are also given the clue that another
number, `ψ = (1 - √5)/2` will be helpful in solving the problem.  It would be
useful to know whether the first property also holds for ψ, i.e. `ψ² = ψ + 1`.

![$
\minipage{1.0\textwidth}
\newtheorem*{theorem}{Theorem}
\begin{theorem}
$\psi^2 = \psi + 1$
\end{theorem}
\begin{proof}
The proof proceeds by simple algebraic substitution.
\begin{align*}
\psi^2 &= \frac{1 - \sqrt{5}}{2} \times \frac{1 - \sqrt{5}}{2} \\
       &= \frac{(1 - \sqrt{5})(1 - \sqrt{5})}{4}               \\
       &= \frac{6 - 2(\sqrt{5})}{4}                            \\
       &= \frac{3 - \sqrt{5}}{2} = \frac{2}{2} + \frac{1 - \sqrt{5}}{2} \\
       &= 1 + \psi && \qedhere
\end{align*}
\end{proof}
\endminipage
$](img/ex1.13-thm1.png?raw=true)

It does!  We can use this property of both Φ and ψ to show that `Φⁿ = Φⁿ⁻¹ +
Φⁿ⁻²`, a property which has parallels with the Fibonacci sequence.

![$
\minipage{1.0\textwidth}
\newtheorem*{theorem}{Theorem}
\begin{theorem}
$\phi^n = \phi^{n-1} + \phi^{n-2}$
\end{theorem}
\begin{proof}
\begin{align*}
\phi^n &= \phi \times \phi^{n-1} = \phi \times \phi \times \phi^{n-2} = \phi^2 \times \phi^{n-2} \\
       &= (\phi + 1) \times \phi^{n-2}  && \text{because $\phi^2 = \phi + 1$}                    \\
       &= \phi^{n-1} + \phi^{n-2}       && \qedhere
\end{align*}
\end{proof}
\endminipage
$](img/ex1.13-thm2.png?raw=true)

I have used Φ in the above calculation, but the proof is identical for ψ.

We now have all the tools we need to prove the assertion made in the text.

![$
\minipage{1.0\textwidth}
\newtheorem*{theorem}{Theorem}
\begin{theorem}
$Fib(n) = \frac{\phi^n - \psi^n}{\sqrt{5}}$
\end{theorem}
\begin{proof}
The proof proceeds by induction on $n$.
\begin{description}
\item[Base cases] \hfill \\
\begin{align*}
\phi^0 &= \frac{\phi^0 - \psi^0}{\sqrt{5}}                            \\
       &= \frac{1-1}{\sqrt{5}}                                        \\
       &= 0 = Fib(0)                                                  \\
\phi^1 &= \frac{\phi^1 - \psi^1}{\sqrt{5}}                            \\
       &= \frac{(1 + \sqrt{5})/2 - (1 - \sqrt{5})/2}{\sqrt{5}}        \\
       &= \frac{\frac{\sqrt{5}}{2} + \frac{\sqrt{5}}{2}}{\sqrt{5}}
        = \frac{\sqrt{5}}{\sqrt{5}}                                   \\
       &= 1 = Fib(1)                                                  \\
\end{align*}

\item[Inductive step] \hfill \\
Assuming the theorem holds for $n - 1$ and $n - 2$ we have:
\begin{align*}
\phi^n &= \frac{\phi^n - \psi^n}{\sqrt{5}}                            \\
       &= \frac{\phi^n}{\sqrt{5}} - \frac{\psi^n}{\sqrt{5}}           \\
       &= \frac{\phi^{n-2} - \psi^{n-2}}{\sqrt{5}} + \frac{\phi^{n-1} - \psi^{n-1}}{\sqrt{5}} \\
       &= Fib(n-2) + Fib(n-1)                                         \\
       &\therefore \text{the theorem holds for all $n$.} && \qedhere
\end{align*}
\end{description}
\end{proof}
\endminipage
$](img/ex1.13-thm3.png?raw=true)

By the time you've got this far you'd be forgiven for having forgotten what the
question was.  We can clearly see a string relationship between Φ and the
Fibonacci sequence, but we're not quite there yet -- the question asks us to
prove that the *closest integer* to `Φⁿ/√5` is Fib(n).  Let's use what we've got
so far to tackle that:

![$
\minipage{1.0\textwidth}
\newtheorem*{theorem}{Theorem}
\theoremstyle{definition}
\newtheorem*{definition}{Definition}
\begin{definition}
We can say that for any natural number $n$ and real number $x$, $n$ is the
closest integer to $x$ iff $|n - x| < \frac{1}{2}$.
\end{definition}
\begin{theorem}
The closest integer to $\phi^n/\sqrt{5}$ is $Fib(n)$
\end{theorem}
\begin{proof}
\begin{align*}
Fib(n)                             &= \frac{\phi^n - \psi^n}{\sqrt{5}} && \text{as shown above}\\
Fib(n) - \frac{\phi^n}{\sqrt{5}}   &= -\frac{\psi^n}{\sqrt{5}}                                 \\
\left|Fib(n) - \frac{\phi^n}{\sqrt{5}}\right| &= \frac{\psi^n}{\sqrt{5}}
  && \therefore \text{the theorem holds so long as $\frac{\psi^n}{\sqrt{5}} < \frac{1}{2}$}    \\
\end{align*}

If we calculate $\frac{\psi^1}{\sqrt{5}}$ we find it is less than $\frac{1}{2}$,
and since raising a fractional number between $0$ and $1$ to any power will
always result in a smaller fraction, $\frac{\psi^n}{\sqrt{5}}$ will always be
less than $\frac{1}{2}$.
\end{proof}
\endminipage
$](img/ex1.13-thm4.png?raw=true)
