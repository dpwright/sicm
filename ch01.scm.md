Building Abstractions with Procedures
=====================================

Exercise 1.2
------------

*Translate the following expression into prefix form*

![$ $\frac {5 + 4 + (2 - (3 - (6 + \frac {4} {5})))} {3(6 - 2)(2 - 7)}$ $](img/ex1.2.png?raw=true)

```scheme
(/ (+ 5 4 (- 2 (- 3 (+ 6 (/ 4 5)))))
   (* 3 (- 6 2) (- 2 7)))
```

Exercise 1.3
------------

*Define a procedure that takes three numbers as arguments and returns the sum
of the squares of the two larger numbers.*

```scheme
(define (ex1.3 x y z)
  (define (square x) (* x x))
  (define (max x y) (if (> x y) x y))
  (define (sum-of-squares x y) (+ (square x) (square y)))
  (if (> x y)
    (+ (sum-of-squares x (max y z)))
    (+ (sum-of-squares y (max x z)))))
```

Exercise 1.4
------------

*Describe the behaviour of the following procedure:*

    (define (a-plus-abs-b a b)
      ((if (> b 0) + -) a b))

This will add b to a if b is positive, otherwise it will subtract it.
In other words it adds the absolute value of b to a.

Exercise 1.5
------------

*Given the procedures:*

    (define (p) (p))
    (define (test x y)
      (if (= x 0)
        0
        y))

*What would be the result of running: (test 0 (p))?*

The answer is of course an infinite loop as it will attempt to evaluate the
value of (p) before calling the function (test) which discards it.  This is in
contrast to what would happen under normal-order (lazy) evaluation, in which
case the computation in the else branch of the if statement would never be run
and so (test 0 (p)) would simply return 0.

Exercise 1.6
------------

*What would happen if we attempted to use the following implementation to
compute square roots?*

    (define (new-if predicate then-clause else-clause)
      (cond (predicate then-clause)
            (else else-clause)))
    (define (sqrt-iter guess x)
      (new-if (good-enough? guess x)
              guess
              (sqrt-iter (improve guess x)
                         x)))

The answer is an infinite loop, for the same reasons as outlined above.

Exercise 1.7
------------

*Design a square-root procedure that stops when the change is a very small
fraction of the guess, rather than when the square of the guess is a small
number away from the required result.*

```scheme
(define (sqrt x)
  (define (good-enough? guess last-guess)
    (< (/ (abs (- guess last-guess))
          guess)
       0.001))

  (define (average x y)
    (/ (+ x y) 2))

  (define (improve guess x)
    (average guess (/ x guess)))

  (define (sqrt-iter guess last-guess x)
    (if (good-enough? guess last-guess)
      guess
      (sqrt-iter (improve guess x)
                 guess
                 x)))

  (sqrt-iter (improve 1.0 x) 1.0 x))
```

Exercise 1.8
------------

*Implement a cube-root procedure analogous to the square-root procedure.*

```scheme
(define (cbrt x)
  (define (good-enough? guess last-guess)
    (< (/ (abs (- guess last-guess))
          guess)
       0.001))

  (define (improve guess x)
    (/ (+ (/ x (square guess)) (* 2 guess))
       3))

  (define (cbrt-iter guess last-guess x)
    (if (good-enough? guess last-guess)
      guess
      (cbrt-iter (improve guess x)
                 guess
                 x)))

  (cbrt-iter (improve 1.0 x) 1.0 x))
```

Exercise 1.9
------------

*Using the substitution model, illustrate the process generated by each of the
following procedures in evaluating `(+ 4 5)`.  Are these processes iterative or
recursive?*

    (define (+ a b)
      (if (= a 0)
          b
          (inc (+ (dec a) b))))

    (define (+ a b)
      (if (= a 0)
          b
          (+ (dec a) (inc b))))

Here is the first one, which is recursive:

```
(+ 4 5)
(inc (+ 3 5))
(inc (inc (+ 2 5)))
(inc (inc (inc (+ 1 5))))
(inc (inc (inc (inc (+ 0 5)))))
(inc (inc (inc (inc 5))))
(inc (inc (inc 6)))
(inc (inc 7)
(inc 8)
9
```

And the second, which is iterative:

```
(+ 4 5)
(+ 3 6)
(+ 2 7)
(+ 1 8)
(+ 0 9)
9
```

Exercise 1.10
-------------

*The following procedure computes a mathematical function calles Ackermann's
function.*

```scheme
(define (A x y)
  (cond ((= y 0) 0)
        ((= x 0) (* 2 y))
        ((= y 1) 2)
        (else    (A (- x 1)
                    (A x (- y 1))))))
```

*What are the values of the following expressions? `(A 1 10)`, `(A 2 4)`,
`(A 3 3)`*

```
(A 1 10)
(A 0 (A 1 9))
(A 0 (A 0 (A 1 8)))
(A 0 (A 0 (A 0 (A 1 7))))
(A 0 (A 0 (A 0 (A 0 (A 1 6)))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 1 5))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 4)))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 3))))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 2)))))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 1))))))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 2)))))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 4))))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 8)))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 16))))))
(A 0 (A 0 (A 0 (A 0 (A 0 32)))))
(A 0 (A 0 (A 0 (A 0 64))))
(A 0 (A 0 (A 0 128)))
(A 0 (A 0 256))
(A 0 512)
1024
```

```
(A 2 4)
(A 1 (A 2 3))
(A 1 (A 1 (A 2 2)))
(A 1 (A 1 (A 1 (A 2 1))))
(A 1 (A 1 (A 1 2)))
(A 1 (A 1 (A 0 (A 1 1))))
(A 1 (A 1 (A 0 2)))
(A 1 (A 1 4))
(A 1 (A 0 (A 1 3)))
(A 1 (A 0 (A 0 (A 1 2))))
(A 1 (A 0 (A 0 (A 0 (A 1 1)))))
(A 1 (A 0 (A 0 (A 0 2))))
(A 1 (A 0 (A 0 4)))
(A 1 (A 0 8))
(A 1 16)
; ...(A 1 n) == 2ⁿ...
65536
```

```
(A 3 3)
(A 2 (A 3 2))
(A 2 (A 2 (A 3 1)))
(A 2 (A 2 2))
(A 2 (A 1 (A 2 1)))
(A 2 (A 1 2))
(A 2 (A 0 (A 1 1)))
(A 2 (A 0 2))
(A 2 4)
(A 1 (A 2 3))
(A 1 (A 1 (A 2 2)))
(A 1 (A 1 (A 1 (A 2 1))))
(A 1 (A 1 (A 1 2)))
(A 1 (A 1 4))
(A 1 16)
65536
```

*Give concise mathematical definitions for the functions computed by the
procedures `f`, `g`, and `h` below, given positive integer values of `n`.  For
example, `(k n)` computes 5n².*

```scheme
(define (f n) (A 0 n))
(define (g n) (A 1 n))
(define (h n) (A 2 n))
(define (k n) (* 5 n n))
```

![$ $f(n) = 2n$ $](img/ex1.10-1.png?raw=true)

![$ $g(n) = 2^n$ $](img/ex1.10-2.png?raw=true)

![$ $h(n) = 2^{2^n}$ $](img/ex1.10-3.png?raw=true)

Example: Counting Change
------------------------

*The following procedure solves the problem of counting how many ways you can
make $1.00 given half-dollars, quarters, dimes, nickels, and pennies.*

```scheme
(define (count-change amount)
  (cc amount 5))

(define (cc amount kinds-of-coins)
  (cond ((= amount 0) 1)
        ((or (< amount 0) (= kinds-of-coins 0)) 0)
        (else (+ (cc amount
                     (- kinds-of-coins 1))
                 (cc (- amount
                        (first-denomination kinds-of-coins))
                        kinds-of-coins)))))

(define (first-denomination kinds-of-coins)
  (cond ((= kinds-of-coins 1) 1)
        ((= kinds-of-coins 2) 5)
        ((= kinds-of-coins 3) 10)
        ((= kinds-of-coins 4) 25)
        ((= kinds-of-coins 5) 50)))
```

*`count-change` generates a tree-recursive process with many redundancies.  On
the other hand, it is not obvious how to design a better algorithm for computing
the result, and we leave this problem as a challenge.*

Exercise 1.11
-------------

*A function `f` is defined by the rule that `f(n) = n` if `n < 3` and `f(n) =
f(n - 1) + 2f(n - 2) + 3f(n - 3)` if n ≥ 3.*

*Write a procedure that computes `f` by means of a recursive process.*

```scheme
(define (f n)
  (if (< n 3)
      n
      (+ (f (- n 1))
         (* 2 (f (- n 2)))
         (* 3 (f (- n 3))))))
```

*Write a procedure that computes `f` by means of an iterative process.*

```scheme
(define (f-iter a b c count)
  (if (= count 0)
    a
    (f-iter b
            c
            (+ c (* 2 b) (* 3 a))
            (- count 1))))

(define (f n)
  (f-iter 0 1 2 n))
```

Exercise 1.12
-------------

*Write a procedure that computes elements of Pascal's triangle by means of a
recursive process.*

```scheme
(define (pascals-triangle row index)
  (if (or (= index 1) (= index row))
      1
      (+ (pascals-triangle (- row 1) (- index 1))
         (pascals-triangle (- row 1) index))))
```

Note that this solution performs no bounds checking, so passing indices ≤ 0 or >
row won't work.
